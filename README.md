A simple emulator of a linear-feedback shift register (LFSR). It operates by taking the bits of the inital value (called _fill_ or _seed_), shifting them one position to the left and replacing the leaving bit with exclusive-or of the leaving bit and bits at special locations in the register called the _taps_. This constitutes one step of the feedback shift register. XOR is a linear map, hence the name. Other linear functions can be used as well. The location and number of the taps is determined by the register's reciprocal characteristic polynomial. It has to satisfy several properties - it is expressed as a polynomial modulo 2, meaning all the coefficients must be either 1 or 0. 
Example: a register with taps at positions 11, 10, 7, 3 will have a feedback polynomial:

x^11 + x^10 + x^7 + x^3 + 1

The one corresponds to the leaving bit.
In order to maximize the length of the LFSR, i.e. for it to have the longest period (the number of steps before it returns to inital state), the polynomial should be primitive. That means, that there should be an even number of taps, and they should all be relatively prime, i.e. have no common divisor other than 1. Read more at [Wolfram MathWorld](http://mathworld.wolfram.com/PrimitivePolynomial.html)
This code is an emulator, meaning that it does not operate on actual bits, but on a Python list of 0s and 1s symbolizing the bits. This allows for clearer presentation. The code contains the main LFSR class, as well as a short demonstration of the functionality. The project was inspired by [this assignment](http://www.cs.princeton.edu/courses/archive/spr15/cos126/assignments/lfsr.html) from the Princeton COS 126 course. Additional information was obtained from Wolfram MathWorld and Wikipedia.
